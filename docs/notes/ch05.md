# 第5章 使用装饰器改善代码

## 1 装饰器的定义

- 定义：装饰器的主要作用是调用装饰器后面的任何内容作为装饰器本身的第一个参数，其结果为装饰器返回的任何内容。
- 函数装饰器
- 类装饰器：其好处包括代码重用的各种好处以及遵守DRY原则的各种好处；可以创建更小、更简单的类，并在以后使用装饰器来改进它们；使用装饰器时，需要应用于特定类的变换逻辑维护容易

## 2 高级装饰器

- 使用嵌套函数实现装饰器：创建一个返回函数的函数，缺点是每创建一个新函数，都必须进一步缩进
- 装饰器对象
- 协程装饰器

## 3 装饰器的常见模式

- 交换参数：修改函数的签名，以暴露更好的API，同时将有关参数被如何处理和变换的细节封装起来。
- 跟踪代码：将函数的执行情况及其参数写入日志。
- 验证参数：可以使用装饰器以透明的方式验证参数的类型。
- 实现重试操作
- 将重复的逻辑移到装饰器中以简化类

## 4 避免常见的错误

- 保留被包装的原始对象的数据：
```python
def decorator(original_function):
    @wraps(original_function)
    def decorated_functuion(*args, **kwargs):
        return original_function(*args, **kwargs)

    return decorated_functuion
```
- 在装饰器中处理副作用
- 创建在任何情况下都管用的装饰器

## 5 使用装饰器整洁代码

- 优良的代码重用方法是创建小而内聚的对象，而不是创建类层次结构。
- 使用装饰器来重用代码的条件：
  1. 不要一开始就白手起家地创建装饰器，等到模式显现出来了且装饰器抽象变得清晰后，再进行重构。
  2. 确定装饰器将被应用多次（至少3次）后再去实现它。
  3. 让装饰器包含的代码尽可能少
- 优良装饰器的特点：
  1. 封装（关注点分离）：将不同的职责有效地分离
  2. 正交性：装饰器所做的事情必须是独立的，并尽可能与它装饰的对象解耦
  3. 可重用性：装饰器应该可以应用于多种不同的类型，而不应只能应用于一个函数的一个实例中